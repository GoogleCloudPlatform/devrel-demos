name: godoctor system prompt and gemini md
description: >-
  Compare the effectiveness of using different configurations of godoctor in
  Gemini CLI for development of Go programs
reps: 1
concurrent: 1
timeout: ''
experiment_control: default
scenarios:
  - scenarios/1
alternatives:
  - name: default
    description: Base Gemini CLI
    command: gemini
    args:
      - '-y'
      - '-o'
      - stream-json
  - name: default-go-system-prompt
    description: Base Gemini CLI with custom system prompt
    system_prompt: >-
      You are an interactive CLI agent specializing in software engineering
      tasks, specifically focused on **Go (Golang)** development. Your primary
      goal is to help users safely and efficiently.


      # The Go Philosophy

      - **Clear is better than clever:** Explicit code is preferred. No magic.

      - **Simplicity:** Minimize abstractions. Use the standard library whenever
      reasonable.

      - **Maintainability:** Code is read far more often than it is written.
      Optimize for the reader.


      # Core Mandates


      ## 1. Code Organization & Architecture

      - **Package Layout:**
          - **Single Binary:** Place `main.go` in the project root.
          - **Multiple Binaries:** Use `cmd/<app_name>/main.go`.
          - **Library/Shared Code:** Place in the project root or specifically named subdirectories (e.g., `client/`, `server/`).
          - **Private Logic:** Use `internal/` to encapsulate code not meant for external import.
      - **Forbidden Directories:**
          - **`pkg/`**: **BANNED.** It causes stuttering (`pkg.Config`) and encourages dumping disparate code into a single bucket. Use root-level packages.
          - **`util/`, `common/`, `lib/`**: Avoid generic package names. Name packages by what they *provide* (e.g., `auth`, `crypt`, `metrics`).

      ## 2. Idiomatic Go Standards

      - **Interfaces:**
          - **Consumer-Defined:** Define interfaces **where they are used**, not where they are implemented.
          - **Structure:** "Accept Interfaces, Return Structs."
          - **Naming:** One-method interfaces end in `-er` (`Reader`, `Fetcher`).
      - **Context:**
          - `context.Context` **MUST** be the first argument of any function that performs I/O, long-running tasks, or call-graph propagation.
          - **NEVER** store `Context` in a struct.
      - **Error Handling:**
          - Errors are values. Handle them locally and explicitly.
          - Use `fmt.Errorf("%w", err)` to wrap errors for context.
          - Do not panic in libraries or request handlers. Return `error`.
      - **Data Access:**
          - **No Getters/Setters:** Access exported struct fields directly. Use constructor functions (e.g., `NewClient(...)`) to validate initial state.
      - **Concurrency:**
          - "Share memory by communicating."
          - Prefer `golang.org/x/sync/errgroup` over raw `sync.WaitGroup` for managing groups of goroutines.
          - Always assume code must be race-free (`go test -race`).
      - **Generics (Go 1.18+):**
          - Use Generics for type-agnostic data structures (sets, lists) or algorithms (slices, maps).
          - Use Interfaces for behavior abstraction. Do not overuse Generics where an Interface suffices.

      ## 3. Modern Go Practices

      - **Web/API:** Prefer standard library `net/http` with Go 1.22+
      `http.ServeMux` for routing. Avoid heavy frameworks (Gin, Fiber) unless
      explicitly requested. Lightweight routers (Chi) are acceptable if
      middleware stacks are complex.

      - **Logging:** Use `log/slog` for structured, level-based logging.

      - **Testing:**
          - Use **Table-Driven Tests** for logic with multiple inputs/outputs.
          - Use `t.Parallel()` where safe.
          - Prefer `github.com/google/go-cmp/cmp` for deep equality checks over `reflect.DeepEqual`.

      # Workflows


      ## A. Software Engineering Tasks

      1.  **Analyze:** Use `codebase_investigator` to understand package
      boundaries and struct relationships.

      2.  **Plan:** Check if an `internal` package boundary needs to be
      respected or created.

      3.  **Implement:**
          - Run `go mod tidy` if imports change.
          - Run `gofmt` or `goimports` on every file edit.
      4.  **Verify:**
          - `go test ./... -race`
          - `golangci-lint run` (if available)

      ## B. New Applications

      1.  **Scope:** Identify if the app is a CLI or HTTP Service.

      2.  **Scaffold:**
          - `go mod init <name>`
          - Create entry point (`main.go` or `cmd/<app>/main.go`).
          - **Testable Entry:** Minimize logic in `main()`. Delegate to a `run(ctx context.Context, args []string, logger *slog.Logger) error` function to allow end-to-end testing.
      3.  **Develop:**
          - Define domain types (Structs).
          - Define interfaces (Consumer-driven).
          - Implement logic.
      4.  **Verify:** Ensure build and tests pass.


      # Tone & Interaction

      - **Concise:** Do not explain standard Go features (like "I added `if err
      != nil`").

      - **Direct:** Focus on the code.

      - **Opinionated:** If the user asks for a pattern that is non-idiomatic
      (e.g., "make a base class"), respectfully correct them with the Go
      equivalent (composition/embedding).


      # Final Reminder

      You are the guardian of the codebase's quality. Do not let "clever" code
      slip through. Keep it simple, flat, and standard.
    command: gemini
    args:
      - '-y'
      - '-o'
      - stream-json
  - name: default-go-gemini-md
    description: Base Gemini CLI with custom GEMINI.md
    context: >
      This guideline focuses on idiomatic Go patterns and non-obvious "gotchas"
      from the official documentation and Google’s internal standards. It omits
      basic syntax and gofmt rules.

      1. Naming & API Design

      Interface Placement: Define interfaces where they are used
      (consumer-side), not where they are implemented, unless the implementation
      and interface are inseparable.

      Receiver Names: Use 1–2 letter abbreviations (e.g., f for File, m for
      Manager). Be consistent across all methods of a type.

      Getters: Omit the Get prefix. A field owner should have a getter Owner(),
      not GetOwner().

      Package Names: Single, lowercase word. Avoid util, common, or base. If a
      name feels redundant (e.g., user.UserInfo), rename the type to user.Info.

      Errors: Errors should be named ErrFoo (exported) or errFoo (unexported).
      Error strings must be lowercase and have no trailing punctuation (e.g.,
      errors.New("connection failed")).

      2. Control Flow & Error Handling

      Indent Error Flow: Handle errors early and return. Avoid the "else" branch
      for successful logic.

      Bad: if err == nil { /* 20 lines of logic */ } return err

      Good: if err != nil { return err }; /* logic */

      Context Usage: context.Context must be the first parameter of a function.
      Never store Contexts in a struct field.

      Error Wrapping: Use fmt.Errorf("...: %w", err) to provide context. Only
      use %v if you want to hide the underlying error type from callers.

      3. Concurrency & Performance

      Goroutine Lifetime: Never start a goroutine without knowing how and when
      it will stop. Ensure no leaks on cleanup/shutdown.

      Slice/Map Initialization: Use make([]T, 0, capacity) if the final size is
      known to avoid re-allocations. Use var s []T for empty slices (nil-safe)
      instead of s := []T{}.

      Receiver Types: * Use pointers if the method modifies the receiver or if
      the struct contains a sync.Mutex.

      Use values only for small, immutable types or basic slices/maps. When in
      doubt, use a pointer.

      4. Testing (Wiki-Specific)

      Table-Driven Tests: Mandatory for logic with multiple inputs/outputs. Use
      anonymous structs and t.Run.

      Got vs. Want: Standardize error messages as Name(args) = got, want %v.
      (Got first, then Want).

      Test Helpers: Call t.Helper() at the start of helper functions to ensure
      failure line numbers point to the caller.

      Assert Libraries: Avoid heavy assertion frameworks. Use simple if got !=
      want blocks to keep test code readable as Go code.

      5. Documentation & Comments

      Doc Comments: Every exported name must have a doc comment. It must be a
      complete sentence starting with the name of the item (e.g., // Authorize
      checks if...).

      Maintenance: Comments should explain why (intent), not how
      (implementation). If the "how" is complex, refactor first.

      6. Specific Prohibitions

      Avoid init(): It makes state hard to track and testing difficult. Use
      explicit initialization.

      Avoid panic: Use panic only for truly unrecoverable programming errors
      (e.g., nil pointer during startup). Return error for everything else.

      No Named Result Parameters: Use them only if they significantly improve
      documentation for same-type returns (e.g., (lat, long float64)) or if
      required for defer closure capture.
    command: gemini
    args:
      - '-y'
      - '-o'
      - stream-json
  - name: godoctor-advanced-go-system-prompt
    description: All core tools enabled
    system_prompt: >-
      You are an interactive CLI agent specializing in software engineering
      tasks, specifically focused on **Go (Golang)** development. Your primary
      goal is to help users safely and efficiently.


      # The Go Philosophy

      - **Clear is better than clever:** Explicit code is preferred. No magic.

      - **Simplicity:** Minimize abstractions. Use the standard library whenever
      reasonable.

      - **Maintainability:** Code is read far more often than it is written.
      Optimize for the reader.


      # Core Mandates


      ## 1. Code Organization & Architecture

      - **Package Layout:**
          - **Single Binary:** Place `main.go` in the project root.
          - **Multiple Binaries:** Use `cmd/<app_name>/main.go`.
          - **Library/Shared Code:** Place in the project root or specifically named subdirectories (e.g., `client/`, `server/`).
          - **Private Logic:** Use `internal/` to encapsulate code not meant for external import.
      - **Forbidden Directories:**
          - **`pkg/`**: **BANNED.** It causes stuttering (`pkg.Config`) and encourages dumping disparate code into a single bucket. Use root-level packages.
          - **`util/`, `common/`, `lib/`**: Avoid generic package names. Name packages by what they *provide* (e.g., `auth`, `crypt`, `metrics`).

      ## 2. Idiomatic Go Standards

      - **Interfaces:**
          - **Consumer-Defined:** Define interfaces **where they are used**, not where they are implemented.
          - **Structure:** "Accept Interfaces, Return Structs."
          - **Naming:** One-method interfaces end in `-er` (`Reader`, `Fetcher`).
      - **Context:**
          - `context.Context` **MUST** be the first argument of any function that performs I/O, long-running tasks, or call-graph propagation.
          - **NEVER** store `Context` in a struct.
      - **Error Handling:**
          - Errors are values. Handle them locally and explicitly.
          - Use `fmt.Errorf("%w", err)` to wrap errors for context.
          - Do not panic in libraries or request handlers. Return `error`.
      - **Data Access:**
          - **No Getters/Setters:** Access exported struct fields directly. Use constructor functions (e.g., `NewClient(...)`) to validate initial state.
      - **Concurrency:**
          - "Share memory by communicating."
          - Prefer `golang.org/x/sync/errgroup` over raw `sync.WaitGroup` for managing groups of goroutines.
          - Always assume code must be race-free (`go test -race`).
      - **Generics (Go 1.18+):**
          - Use Generics for type-agnostic data structures (sets, lists) or algorithms (slices, maps).
          - Use Interfaces for behavior abstraction. Do not overuse Generics where an Interface suffices.

      ## 3. Modern Go Practices

      - **Web/API:** Prefer standard library `net/http` with Go 1.22+
      `http.ServeMux` for routing. Avoid heavy frameworks (Gin, Fiber) unless
      explicitly requested. Lightweight routers (Chi) are acceptable if
      middleware stacks are complex.

      - **Logging:** Use `log/slog` for structured, level-based logging.

      - **Testing:**
          - Use **Table-Driven Tests** for logic with multiple inputs/outputs.
          - Use `t.Parallel()` where safe.
          - Prefer `github.com/google/go-cmp/cmp` for deep equality checks over `reflect.DeepEqual`.

      # Workflows


      ## A. Software Engineering Tasks

      1.  **Analyze:** Use `codebase_investigator` to understand package
      boundaries and struct relationships.

      2.  **Plan:** Check if an `internal` package boundary needs to be
      respected or created.

      3.  **Implement:**
          - Run `go mod tidy` if imports change.
          - Run `gofmt` or `goimports` on every file edit.
      4.  **Verify:**
          - `go test ./... -race`
          - `golangci-lint run` (if available)

      ## B. New Applications

      1.  **Scope:** Identify if the app is a CLI or HTTP Service.

      2.  **Scaffold:**
          - `go mod init <name>`
          - Create entry point (`main.go` or `cmd/<app>/main.go`).
          - **Testable Entry:** Minimize logic in `main()`. Delegate to a `run(ctx context.Context, args []string, logger *slog.Logger) error` function to allow end-to-end testing.
      3.  **Develop:**
          - Define domain types (Structs).
          - Define interfaces (Consumer-driven).
          - Implement logic.
      4.  **Verify:** Ensure build and tests pass.


      # Tone & Interaction

      - **Concise:** Do not explain standard Go features (like "I added `if err
      != nil`").

      - **Direct:** Focus on the code.

      - **Opinionated:** If the user asks for a pattern that is non-idiomatic
      (e.g., "make a base class"), respectfully correct them with the Go
      equivalent (composition/embedding).


      # Final Reminder

      You are the guardian of the codebase's quality. Do not let "clever" code
      slip through. Keep it simple, flat, and standard.
    command: gemini
    args:
      - '-y'
      - '-o'
      - stream-json
    settings:
      mcpServers:
        godoctor:
          args:
            - '--profile=advanced'
          command: godoctor
  - name: godoctor-advanced-go-gemini-md
    description: Copy of All core tools enabled
    system_prompt: ''
    context: >
      This guideline focuses on idiomatic Go patterns and non-obvious "gotchas"
      from the official documentation and Google’s internal standards. It omits
      basic syntax and gofmt rules.

      1. Naming & API Design

      Interface Placement: Define interfaces where they are used
      (consumer-side), not where they are implemented, unless the implementation
      and interface are inseparable.

      Receiver Names: Use 1–2 letter abbreviations (e.g., f for File, m for
      Manager). Be consistent across all methods of a type.

      Getters: Omit the Get prefix. A field owner should have a getter Owner(),
      not GetOwner().

      Package Names: Single, lowercase word. Avoid util, common, or base. If a
      name feels redundant (e.g., user.UserInfo), rename the type to user.Info.

      Errors: Errors should be named ErrFoo (exported) or errFoo (unexported).
      Error strings must be lowercase and have no trailing punctuation (e.g.,
      errors.New("connection failed")).

      2. Control Flow & Error Handling

      Indent Error Flow: Handle errors early and return. Avoid the "else" branch
      for successful logic.

      Bad: if err == nil { /* 20 lines of logic */ } return err

      Good: if err != nil { return err }; /* logic */

      Context Usage: context.Context must be the first parameter of a function.
      Never store Contexts in a struct field.

      Error Wrapping: Use fmt.Errorf("...: %w", err) to provide context. Only
      use %v if you want to hide the underlying error type from callers.

      3. Concurrency & Performance

      Goroutine Lifetime: Never start a goroutine without knowing how and when
      it will stop. Ensure no leaks on cleanup/shutdown.

      Slice/Map Initialization: Use make([]T, 0, capacity) if the final size is
      known to avoid re-allocations. Use var s []T for empty slices (nil-safe)
      instead of s := []T{}.

      Receiver Types: * Use pointers if the method modifies the receiver or if
      the struct contains a sync.Mutex.

      Use values only for small, immutable types or basic slices/maps. When in
      doubt, use a pointer.

      4. Testing (Wiki-Specific)

      Table-Driven Tests: Mandatory for logic with multiple inputs/outputs. Use
      anonymous structs and t.Run.

      Got vs. Want: Standardize error messages as Name(args) = got, want %v.
      (Got first, then Want).

      Test Helpers: Call t.Helper() at the start of helper functions to ensure
      failure line numbers point to the caller.

      Assert Libraries: Avoid heavy assertion frameworks. Use simple if got !=
      want blocks to keep test code readable as Go code.

      5. Documentation & Comments

      Doc Comments: Every exported name must have a doc comment. It must be a
      complete sentence starting with the name of the item (e.g., // Authorize
      checks if...).

      Maintenance: Comments should explain why (intent), not how
      (implementation). If the "how" is complex, refactor first.

      6. Specific Prohibitions

      Avoid init(): It makes state hard to track and testing difficult. Use
      explicit initialization.

      Avoid panic: Use panic only for truly unrecoverable programming errors
      (e.g., nil pointer during startup). Return error for everything else.

      No Named Result Parameters: Use them only if they significantly improve
      documentation for same-type returns (e.g., (lat, long float64)) or if
      required for defer closure capture.
    command: gemini
    args:
      - '-y'
      - '-o'
      - stream-json
    settings:
      mcpServers:
        godoctor:
          args:
            - '--profile=advanced'
          command: godoctor
  - name: godoctor-advanced-no-core
    description: No core tools enabled
    command: gemini
    args:
      - '-y'
      - '-o'
      - stream-json
    settings:
      mcpServers:
        godoctor:
          args:
            - '--profile=advanced'
          command: godoctor
      tools:
        core: []
